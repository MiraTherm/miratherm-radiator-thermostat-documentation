%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% LICENSE NOTICE (CC BY 4.0)
%
% Author/Creator: Alexander Menzel
% Copyright: 2025 MiraTherm
%
% This work is licensed under the Creative Commons Attribution 4.0 International License.
% License Text (URI): https://creativecommons.org/licenses/by/4.0/
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[conference,nofonttune]{IEEEtran}
\IEEEoverridecommandlockouts
%
%--Packages-------------------------------------------------------------------%
%
\input{config/packages}
%
%--Customization--------------------------------------------------------------%
%
\input{config/customization}
%
%--Document--------------------------------------------------------------------%
%
\begin{document}
%
%--Title and Authors-----------------------------------------------------------%
%
\title{Decoupling UI Logic in Embedded Systems: Technical Design of R-MVP-based Thermostat Software\\
% Note: Sub-titles are not captured in Xplore and should not be used
%\thanks{Identify applicable funding agency here. If none, delete this.}
}
%
% Note: The class file is designed for, but not limited to, six authors.
%
% Add 1\textsuperscript{st} before the name of the first author, if there are 
% multiple authors.
%
\author{\IEEEauthorblockN{Alexander Menzel\orcidlink{0009-0007-3904-0439}}
\IEEEauthorblockA{\textit{Department of Electrical Engineering} \\
\textit{Fulda University of Applied Sciences}\\
Fulda, Germany \\
alexander.menzel@et.hs-fulda.de
}
% \and
% \IEEEauthorblockN{2\textsuperscript{nd} Given Name Surname}
% \IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
% \textit{name of organization (of Aff.)}\\
% City, Country \\
% email address or ORCID}
}
%
\maketitle
%
%--Abstract and Keywords--------------------------------------------------------%
%
\begin{abstract}
Text\dots
\end{abstract}
%
\begin{IEEEkeywords}
keyword1, keyword2, keyword3, keyword4, keyword5
\end{IEEEkeywords}
%
%--Sections--------------------------------------------------------------------%
%

\section{Introduction}
\label{sec:Introduction}
Heating private living spaces is one of the most significant sources of $CO_2$ emissions. In Germany, a substantial portion of annual greenhouse gas emissions originates from this sector \cite{StatistischesBundesamt.16.07.2025} \cite{Umweltbundesamt.15.03.2022}. While intelligent heating control and smart home systems offer an average energy saving potential of between 8 and 19\% \cite{Kersken.2018}, the market is currently dominated by proprietary solutions. Consequently, there is a lack of open-domain projects that can serve as a foundation for research and development of smart heating controllers.

This paper presents the software development for a radiator thermostat prototype, realized as part of the interdisciplinary ``MiraTherm Radiator Thermostat'' project at Fulda University of Applied Sciences. The overarching project aims to create a complete device, encompassing mechanics, electronics, and control algorithms.

The primary objective of this work is to establish a solid software foundation for the thermostat's microcontroller-based hardware. While the long-term vision includes control algorithms and wireless connectivity (e.g., Matter-over-Thread), the central contribution of this paper lies in the architectural design of the application and its User Interface (UI). Specifically, we propose the application of the Routed-Model-View-Presenter (R-MVP) design pattern in order to decouple UI logic from hardware drivers and core system logic. This approach is used to implement basic consumer functions considering constraints of an embedded system and of the C programming language.

\section{Background} % and Related Work
\label{sec:Background}
This section provides the necessary context for this work. First, the domain of smart radiator thermostats is introduced. Then, the Model-View-Presenter (MVP) design pattern, which forms the architectural basis for the software, is described.

\subsection{Smart Radiator Thermostats}
\label{subsec:Smart Radiator Thermostats}
A radiator thermostat is a device mounted on a heating radiator valve to control the flow of hot water, thereby regulating the room temperature. Traditional thermostatic radiator valves (TRVs) use a wax or liquid-filled capsule that expands and contracts with temperature changes, mechanically adjusting valve position. Digital radiator thermostats replace this mechanism with an electronically controlled system, typically consisting of a microcontroller unit (MCU), a DC motor with a gearbox for valve actuation, a user interface (buttons, rotary encoder, display), and a motor driver circuit.

Smart radiator thermostats extend the digital concept with wireless connectivity, such as Wi-Fi, Bluetooth Low Energy (BLE), or emerging standards like Matter-over-Thread, enabling integration into smart home ecosystems and remote control via mobile applications. Common consumer functions of such devices include manual temperature adjustment, mode selection (e.g., auto, manual, boost, vacation), weekly schedule programming, an open-window detection function, and a periodic valve decalcification program \cite{eQ3AG.05.2018, ELVjournal.2012}. They are most commonly battery-powered and are expected to operate for extended periods, typically around two years on two AA batteries \cite{eQ3AG.05.2018, ELVjournal.2012}.

The software presented in this paper uses the eQ-3 eqiva Bluetooth Smart Radiator Thermostat \cite{eQ3AG.05.2018} as a functional reference for defining its scope.

\subsection{MVP Pattern}
\label{sec:MVP}
The Model-View-Presenter (MVP) pattern is a derivative of the classic Model-View-Controller (MVC) pattern developed in the late 1970's. MVP is described in \cite{Potel.1996} as a generalization of MVC that decomposes an application's design into two fundamental domains: \textit{Data Management} and \textit{User Interface}.

In the Data Management domain, a developer must address three sub-questions:
\begin{enumerate}
    \item \textit{What is my data?} --- answered by the \textbf{Model}, which encapsulates the application's data and its access methods;
    \item \textit{How do I specify my data?} --- answered by \textbf{Selections}, which represent abstractions for identifying subsets of the model's data;
    \item \textit{How do I change my data?} --- answered by \textbf{Commands}, which represent operations that can be performed on selections \cite{Potel.1996}.
\end{enumerate}

In the User Interface domain, three further questions are posed:
\begin{enumerate}
    \setcounter{enumi}{3}
    \item \textit{How do I display my data?} --- answered by the \textbf{View}, which renders a representation of the model's data (Views need not be graphical.);
    \item \textit{How do events map into changes in my data?} --- answered by \textbf{Interactors}, which handle user-initiated actions such as mouse clicks, keystrokes, or physical input like turning a dial;
    \item \textit{How do I put it all together?} --- answered by the \textbf{Presenter}, which coordinates all other elements by providing the business logic that maps user gestures onto the appropriate commands for manipulating the model \cite{Potel.1996}.
\end{enumerate}

\begin{figure}[htbp]
    \centerline{\includegraphics[width=\columnwidth]{figures/mvp-six-questions.png}}
    \caption{The six design questions of the MVP programming model and their corresponding abstractions \cite{Potel.1996}}
    \label{fig:mvp-six-questions}
\end{figure}

A key insight from \cite{Potel.1996} is that these abstractions need not all be employed at once. A developer can start with only a subset of the MVP elements---such as the Model, View, and Presenter---and incrementally introduce Selections, Commands, and Interactors as the application evolves and requires their respective benefits, such as undo/redo capability, scriptability, or advanced input handling. 

This incremental adoption is particularly relevant for the embedded context of this work, where the constrained environment and the C programming language favor a minimal yet well-structured architecture. Accordingly, the design presented in this paper deliberately omits the Command, Selection, and Interactor abstractions, retaining only the core Model, View, and Presenter triad as the foundation of its UI architecture.

\section{Requirements}
\label{sec:Requirements}
The software requirements for the thermostat prototype are defined in a separate specification document \cite{Menzel.2026.Spec}. This section provides a condensed overview of the key functional and non-functional requirements that drive the technical design.

The functional requirements specify the integration of hardware peripherals shown in \autoref{fig:mt-rt-sw-dev-hw-block-diagram}. A display, a rotary encoder, three buttons and a motor driver must be connected to the STM32WB55 MCU on its development board. Measurement of temperature, motor current and supply voltage (\texttt{V\_BAT}) must be performed. \cite{Menzel.2026.Spec}
\begin{figure}[htbp]
    \centerline{\includegraphics[width=\columnwidth]{../../electronics/diagrams/mt-rt-sw-dev-hw-block-diagram.png}}
    \caption{Block diagram of the thermostat's prototype hardware for software development and testing \cite{Menzel.2026.Spec}.}
    \label{fig:mt-rt-sw-dev-hw-block-diagram}
\end{figure}

The thermostat must support three operational modes: \textit{Auto}, \textit{Manual}, and \textit{Boost}. In Auto mode, the target temperature follows a user-configured daily schedule; in Manual mode, the user sets it directly; and Boost mode provides a temporary override with a countdown display. \cite{Menzel.2026.Spec}

A Configuration on Device (COD) routine is required at startup, guiding the user through date/time setup, daily schedule programming, and a valve adaptation procedure. \cite{Menzel.2026.Spec}

The home display page must directly reflect the current thermostat state (e.g, current time, battery level, target temperature etc.). A menu provides access to schedule changes, temperature offset configuration, and factory reset. All user settings must persist in non-volatile memory across power cycles. \cite{Menzel.2026.Spec}

The non-functional requirements mandate a modular architecture with hardware abstraction layers to allow easy replacement of individual hardware components (e.g., display, motor driver, temperature sensor) with minimal code changes. The UI must provide contextual button hints on every page, indicating the function assigned to each physical button. \cite{Menzel.2026.Spec}

\section{Technical Design}
\label{sec:Technical Design}
This section presents the software architecture and the adapted design pattern used for the UI implementation. The design addresses the requirements from \autoref{sec:Requirements} by establishing a modular, task-based structure that separates hardware interaction, control logic, and user interface concerns.

\subsection{Overall Architecture}
\label{subsec:Overall Architecture}
The software is written in C and uses FreeRTOS for real-time task scheduling and resource management. The architecture follows a modular design that separates hardware abstraction, core control logic, and UI management into distinct FreeRTOS tasks. Each task runs as a singleton and is started at system boot. The architecture is designed to enable future integration of control algorithms and the Matter-over-Thread standard with minimal effort. \autoref{fig:mt-rt-sw-architecture} shows the overall architecture.

\begin{figure*}[htbp]
    \includegraphics[width=\textwidth]{../diagrams/mt-rt-sw-architecture.png}
    \caption{Architecture of the radiator thermostat software.}
    \label{fig:mt-rt-sw-architecture}
\end{figure*}

\subsubsection{Synchronization and Data Structures}
\label{subsubsec:Synchronization and Data Structures}
Tasks communicate using FreeRTOS event queues and mutex-protected data structures. All synchronization primitives are created and passed to tasks as parameters before the scheduler is started, preventing deadlocks and priority inversion.

Event queues provide one-way communication between task pairs for signaling and synchronizing state changes (e.g., initialization completion, adaptation requests). Bidirectional communication between two tasks uses two dedicated queues.

Shared data is organized into mutex-protected \textit{Model} structures, each encapsulating a mutex together with the data it protects:
\begin{itemize}
    \item \textbf{SensorModel}: Latest sensor readings (temperature, battery state of charge, motor current).
    \item \textbf{ConfigModel}: User-configurable settings, automatically persisted to non-volatile memory on every update.
    \item \textbf{SystemModel}: Volatile runtime data (system state, current operational mode, target temperature, active time slot, etc.).
\end{itemize}

\subsubsection{Application Layer}
\label{subsubsec:Application Layer}
The application layer consists of the following tasks:
\begin{itemize}
    \item \textbf{SystemTask}: Central coordinator managing the high-level state machine. It orchestrates transitions between operational modes, assigns the target temperature, and communicates with other tasks via events (e.g., \texttt{EVT\_SYS\_INIT\_END}, \texttt{EVT\_ADAPT\_REQ}).
    \item \textbf{InputTask}: Converts hardware signals from the rotary encoder and buttons into logical input events (e.g., \texttt{EVT\_MENU\_BTN}, \texttt{EVT\_CTRL\_WHEEL\_DELTA}) forwarded to the ViewPresenterTask.
    \item \textbf{ViewPresenterTask}: Manages the UI using the R-MVP pattern (see \autoref{subsec:R-MVP Pattern}). It receives input events, accesses shared models, and renders UI elements via the LVGL graphics library.
    \item \textbf{SensorTask}: Periodically reads raw sensor data (via ADC/DMA), converts it to internal units, and updates the SensorModel.
    \item \textbf{StorageTask}: Manages non-volatile memory through an EEPROM emulation layer, ensuring configuration persistence.
    \item \textbf{MaintenanceTask}: Handles non-standard operations such as valve adaptation and descaling, triggered by commands from the SystemTask.
\end{itemize}

\subsubsection{Hardware Abstraction Layer}
\label{subsubsec:Hardware Abstraction Layer}
A Hardware Abstraction Layer (HAL) provides interfaces for the display (LVGL display port for SH1106), the motor driver (IN1/IN2 interface for DRV8833), the rotary encoder (quadrature decoder), and the push buttons (interrupt-driven). This layer satisfies the replaceability requirement by isolating hardware-specific code from application logic.

\subsection{R-MVP Pattern}
Text\dots

\section{Implementation}
Text\dots

\section{Verification and Results}
Text\dots
\subsection{Test Environment}
Text\dots
\subsection{Results}
Text\dots


\section{Conclusion}
Text\dots

%
%--Example Content-------------------------------------------------------------%
%
% Paragraphs example:

% \paragraph{Paragraph 1} 
% Text\dots
% \paragraph{Paragraph 2} 
% Test citation: \cite{IEEEwebsite}.

% Table example:

% \begin{table}[htbp]
% \caption{Table Type Styles}
% \begin{center}
% \begin{tabular}{|c|c|c|c|}
% \hline
% \textbf{Table}&\multicolumn{3}{|c|}{\textbf{Table Column Head}} \\
% \cline{2-4} 
% \textbf{Head} & \textbf{\textit{Table column subhead}}& \textbf{\textit{Subhead}}& \textbf{\textit{Subhead}} \\
% \hline
% copy& More table copy$^{\mathrm{a}}$& &  \\
% \hline
% \multicolumn{4}{l}{$^{\mathrm{a}}$Sample of a Table footnote.}
% \end{tabular}
% \label{tab1}
% \end{center}
% \end{table}

% Figure example:

% \begin{figure}[htbp]
% \centerline{\includegraphics{figures/fig1.png}}
% \caption{Example of a figure caption.}
% \label{fig}
% \end{figure}

%
%--Appendices-------------------------------------------------------------------%
%
%\appendices

% Appendix A
%\section{Title of Appendix A}
%Text\dots

% Appendix B
%\section{}
%Text\dots

%--Acknowledgment---------------------------------------------------------------%
%\section*{Acknowledgment}
%Text\dots

%--Bibliography-----------------------------------------------------------------%
\bibliographystyle{IEEEtran}
\bibliography{./bibtex/bib/bibliography}

\end{document}
