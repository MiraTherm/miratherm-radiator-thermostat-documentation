%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% LICENSE NOTICE (CC BY 4.0)
%
% Author/Creator: Alexander Menzel
% Copyright: 2025 MiraTherm
%
% This work is licensed under the Creative Commons Attribution 4.0 International License.
% License Text (URI): https://creativecommons.org/licenses/by/4.0/
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[conference,nofonttune]{IEEEtran}
\IEEEoverridecommandlockouts
%
%--Packages-------------------------------------------------------------------%
%
\input{config/packages}
%
%--Customization--------------------------------------------------------------%
%
\input{config/customization}
%
%--Document--------------------------------------------------------------------%
%
\begin{document}
%
%--Title and Authors-----------------------------------------------------------%
%
\title{Decoupling UI Logic in Embedded Systems: Technical Design of R-MVP-based Thermostat Software\\
% Note: Sub-titles are not captured in Xplore and should not be used
%\thanks{Identify applicable funding agency here. If none, delete this.}
}
%
% Note: The class file is designed for, but not limited to, six authors.
%
% Add 1\textsuperscript{st} before the name of the first author, if there are 
% multiple authors.
%
\author{\IEEEauthorblockN{Alexander Menzel\orcidlink{0009-0007-3904-0439}}
\IEEEauthorblockA{\textit{Department of Electrical Engineering} \\
\textit{Fulda University of Applied Sciences}\\
Fulda, Germany \\
alexander.menzel@et.hs-fulda.de
}
% \and
% \IEEEauthorblockN{2\textsuperscript{nd} Given Name Surname}
% \IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
% \textit{name of organization (of Aff.)}\\
% City, Country \\
% email address or ORCID}
}
%
\maketitle
%
%--Abstract and Keywords--------------------------------------------------------%
%
\begin{abstract}
Text\dots
\end{abstract}
%
\begin{IEEEkeywords}
keyword1, keyword2, keyword3, keyword4, keyword5
\end{IEEEkeywords}
%
%--Sections--------------------------------------------------------------------%
%

\section{Introduction}
\label{sec:Introduction}
Heating private living spaces is one of the most significant sources of $CO_2$ emissions. In Germany, a substantial portion of annual greenhouse gas emissions originates from this sector \cite{StatistischesBundesamt.16.07.2025} \cite{Umweltbundesamt.15.03.2022}. While intelligent heating control and smart home systems offer an average energy saving potential of between 8 and 19\% \cite{Kersken.2018}, the market is currently dominated by proprietary solutions. Consequently, there is a lack of open-domain projects that can serve as a foundation for research and development of smart heating controllers.

This paper presents the software development for a radiator thermostat prototype, realized as part of the interdisciplinary ``MiraTherm Radiator Thermostat'' project at Fulda University of Applied Sciences. The overarching project aims to create a complete device, encompassing mechanics, electronics, and control algorithms.

The primary objective of this work is to establish a solid software foundation for the thermostat's microcontroller-based hardware. While the long-term vision includes control algorithms and wireless connectivity (e.g., Matter-over-Thread), the central contribution of this paper lies in the architectural design of the application and its User Interface (UI). Specifically, we propose the application of the Routed-Model-View-Presenter (R-MVP) design pattern in order to decouple UI logic from hardware drivers and core system logic. This approach is used to implement basic consumer functions considering constraints of an embedded system and of a verbose programming language.

\section{Background} % and Related Work
\label{sec:Background}
This section provides the necessary context for this work. First, the domain of smart radiator thermostats is introduced. Then, the Model-View-Presenter (MVP) design pattern, which forms the architectural basis for the software, is described.

\subsection{Smart Radiator Thermostats}
\label{subsec:Smart Radiator Thermostats}
A radiator thermostat is a device mounted on a heating radiator valve to control the flow of hot water, thereby regulating the room temperature. Traditional thermostatic radiator valves (TRVs) use a wax or liquid-filled capsule that expands and contracts with temperature changes, mechanically adjusting valve position. Digital radiator thermostats replace this mechanism with an electronically controlled system, typically consisting of a microcontroller unit (MCU), a DC motor with a gearbox for valve actuation, a user interface (buttons, rotary encoder, display), and a motor driver circuit.

Smart radiator thermostats extend the digital concept with wireless connectivity, such as Wi-Fi, Bluetooth Low Energy (BLE), or emerging standards like Matter-over-Thread, enabling integration into smart home ecosystems and remote control via mobile applications. Common consumer functions of such devices include manual temperature adjustment, mode selection (e.g., auto, manual, boost, vacation), weekly schedule programming, an open-window detection function, a periodic valve decalcification program and others \cite{eQ3AG.05.2018, ELVjournal.2012}. They are most commonly battery-powered and are expected to operate for extended periods, typically around two years on two AA batteries \cite{eQ3AG.05.2018, ELVjournal.2012}.

The software presented in this paper uses the eQ-3 eqiva Bluetooth Smart Radiator Thermostat \cite{eQ3AG.05.2018} as a functional reference for defining its scope.

\subsection{MVP Pattern}
\label{sec:MVP}
The Model-View-Presenter (MVP) pattern is a derivative of the classic Model-View-Controller (MVC) pattern developed in the late 1970s. MVP is described in \cite{Potel.1996} as a generalization of MVC that decomposes an application's design into two fundamental domains: \textit{Data Management} and \textit{User Interface}.

In the Data Management domain, a developer must address three sub-questions:
\begin{enumerate}
    \item \textit{What is my data?} --- answered by the \textbf{Model}, which encapsulates the application's data and its access methods;
    \item \textit{How do I specify my data?} --- answered by \textbf{Selections}, which represent abstractions for identifying subsets of the model's data;
    \item \textit{How do I change my data?} --- answered by \textbf{Commands}, which represent operations that can be performed on selections \cite{Potel.1996}.
\end{enumerate}

In the User Interface domain, three further questions are posed:
\begin{enumerate}
    \setcounter{enumi}{3}
    \item \textit{How do I display my data?} --- answered by the \textbf{View}, which renders a representation of the model's data (Views need not be graphical.);
    \item \textit{How do events map into changes in my data?} --- answered by \textbf{Interactors}, which handle user-initiated actions such as mouse clicks, keystrokes, or physical input like turning a dial;
    \item \textit{How do I put it all together?} --- answered by the \textbf{Presenter}, which coordinates all other elements by providing the business logic that maps user gestures onto the appropriate commands for manipulating the model \cite{Potel.1996}.
\end{enumerate}

\begin{figure}[htbp]
    \centerline{\includegraphics[width=\columnwidth]{figures/mvp-six-questions.png}}
    \caption{The six design questions of the MVP programming model and their corresponding abstractions \cite{Potel.1996}.}
    \label{fig:mvp-six-questions}
\end{figure}

A key insight from \cite{Potel.1996} is that these abstractions need not all be employed at once. A developer can start with only a subset of the MVP elements---such as the Model, View, and Presenter---and introduce other if the application requires their respective benefits, such as undo/redo capability, scriptability, or advanced input handling. 

This partial adoption is particularly relevant for the embedded context of this work, where the constrained environment and the use of a verbose programming language favor a minimal yet well-structured architecture. Accordingly, the design of an application can deliberately omit the Command, Selection, and Interactor abstractions, retaining only the core Model, View, and Presenter triad as the foundation of its UI architecture. 

\autoref{fig:mvp} illustrates data flow in this simplified programming model. The View and Presenter are decoupled from each other, with the Presenter serving as the sole mediator between the View and the Model.

\begin{figure}[htbp]
    \centerline{\includegraphics[height=0.25\textheight]{../diagrams/mvp.png}}
    \caption{Data flow in the MVP programming model (mod. from \cite{Perrouin.2017, MVP.Wikipedia.2024}).}
    \label{fig:mvp}
\end{figure}

\section{Requirements}
\label{sec:Requirements}
The software requirements for the thermostat prototype are defined in \cite{Menzel.2026.Spec} as a separate specification document. This section provides a condensed overview of the key functional and non-functional requirements that drive the technical design.

The functional requirements specify the integration of hardware peripherals shown in \autoref{fig:mt-rt-sw-dev-hw-block-diagram}. A display, a rotary encoder, three buttons, and a motor driver must be connected to the STM32WB55 MCU on its development board. Measurement of temperature, motor current, and supply voltage (\texttt{V\_BAT}) must be performed. \cite{Menzel.2026.Spec}
\begin{figure}[htbp]
    \centerline{\includegraphics[width=\columnwidth]{../../electronics/diagrams/mt-rt-sw-dev-hw-block-diagram.png}}
    \caption{Block diagram of the thermostat's prototype hardware for software development and testing \cite{Menzel.2026.Spec}.}
    \label{fig:mt-rt-sw-dev-hw-block-diagram}
\end{figure}

The thermostat must support three operational modes: \textit{Auto}, \textit{Manual}, and \textit{Boost}. In Auto mode, the target temperature follows a configured daily schedule; in Manual mode, the user sets it directly; and Boost mode provides a temporary override with a countdown display. \cite{Menzel.2026.Spec}

A Configuration on Device (COD) routine is required at startup, guiding the user through date/time setup, daily schedule programming, and a valve adaptation procedure. \cite{Menzel.2026.Spec}

The home display page must directly reflect the current thermostat state (e.g., current time, battery level, target temperature). A menu provides access to schedule changes, temperature offset configuration, and factory reset. All user settings must persist in non-volatile memory across power cycles. \cite{Menzel.2026.Spec}

The non-functional requirements mandate a modular architecture with hardware abstraction layers to allow easy replacement of individual hardware components (e.g., display, motor driver, temperature sensor) with minimal code changes. The UI must provide contextual button hints on every page, indicating the function assigned to each physical button. \cite{Menzel.2026.Spec}

\section{Technical Design}
\label{sec:Technical Design}
This section presents the software architecture and the adapted design pattern used for the UI implementation. The design addresses the requirements from \autoref{sec:Requirements} by establishing a modular, task-based structure that separates hardware interaction, control logic, and user interface concerns.

\subsection{Overall Architecture}
\label{subsec:Overall Architecture}
The software is written in C and uses FreeRTOS for real-time task scheduling and resource management. The architecture follows a modular design that separates hardware abstraction, core control logic, and UI management into distinct FreeRTOS tasks. Each task runs as a singleton and is started at system boot. The architecture is designed to enable future integration of control algorithms and the Matter-over-Thread standard with minimal effort. \autoref{fig:mt-rt-sw-architecture} shows the overall architecture.

\begin{figure*}[htbp]
    \includegraphics[width=\textwidth]{../diagrams/mt-rt-sw-architecture.png}
    \caption{Architecture of the radiator thermostat software.}
    \label{fig:mt-rt-sw-architecture}
\end{figure*}

\subsubsection{Synchronization and Data Structures}
\label{subsubsec:Synchronization and Data Structures}
Tasks communicate using FreeRTOS event queues and mutex-protected data structures. All synchronization primitives are created and passed to tasks as parameters before the scheduler is started, preventing deadlocks and priority inversion.

Event queues provide one-way communication between task pairs for signaling and synchronizing state changes (e.g., initialization completion, adaptation requests). Bidirectional communication between two tasks uses two dedicated queues.

Shared data is organized into mutex-protected \textit{Model} structures, each encapsulating a mutex together with the data it protects:
\begin{itemize}
    \item \textbf{SensorModel}: Latest sensor readings (temperature, battery state of charge, motor current).
    \item \textbf{ConfigModel}: User-configurable settings, automatically persisted to non-volatile memory on every update.
    \item \textbf{SystemModel}: Volatile runtime data (system state, current operational mode, target temperature, active time slot, etc.).
\end{itemize}

\subsubsection{Application Layer}
\label{subsubsec:Application Layer}
The application layer consists of the following tasks:
\begin{itemize}
    \item \textbf{SystemTask}: Central coordinator managing the high-level state machine. It orchestrates transitions between operational modes, assigns the target temperature, and communicates with other tasks via events (e.g., \texttt{EVT\_SYS\_INIT\_END}, \texttt{EVT\_ADAPT\_REQ}).
    \item \textbf{InputTask}: Converts hardware signals from the rotary encoder and buttons into logical input events (e.g., \texttt{EVT\_MENU\_BTN}, \texttt{EVT\_CTRL\_WHEEL\_DELTA}) forwarded to the ViewPresenterTask.
    \item \textbf{ViewPresenterTask}: Manages the UI using the R-MVP pattern (see \autoref{subsec:R-MVP Pattern}). It receives input events, accesses shared models, and renders UI elements via the LVGL graphics library.
    \item \textbf{SensorTask}: Periodically reads raw sensor data (via ADC/DMA), converts it to internal units, and updates the SensorModel.
    \item \textbf{StorageTask}: Manages non-volatile memory through an EEPROM emulation layer, ensuring configuration persistence.
    \item \textbf{MaintenanceTask}: Handles non-standard operations such as valve adaptation and descaling, triggered by commands from the SystemTask.
\end{itemize}

\subsubsection{Hardware Abstraction Layer}
\label{subsubsec:Hardware Abstraction Layer}
A self implemented Hardware Abstraction Layer (HAL) provides interfaces for the display (LVGL display port for SH1106), the motor driver (IN1/IN2 interface for DRV8833), the rotary encoder (quadrature decoder), and the push buttons (interrupt-driven). This layer satisfies the replaceability requirement by isolating hardware-specific code from application logic.

\subsection{R-MVP Pattern}
\label{subsec:R-MVP Pattern}
The classical MVC pattern does not enforce a strict decoupling between Model and View---the View can directly observe and access the Model, which makes it difficult to develop these components independently. MVP addresses this by introducing the Presenter as an intermediary: the View only communicates with the Presenter, and the Presenter mediates all access to the Model \cite{Ramsdale.2010}. This separation is the primary reason for choosing MVP over MVC as the basis for the thermostat's UI architecture.

However, classical MVP relies on rich, automated UI widgets (Interactors) that generate high-level semantic events---an assumption rooted in desktop frameworks such as those in Windows or Taligent's CommonPoint \cite{Kratochvil.2011}. In the embedded context of this work, no such widget infrastructure is available. User input must therefore be handled manually, closer to the approach taken in MVC.

While the LVGL graphics library does offer an encoder input device abstraction \cite{LVGL.Encoder.2025}, interaction model of this library is primarily designed for touchscreen or mouse/keyboard interfaces. Integration of an encoder in LVGL---based on widget focus groups, edit modes, and long-press transitions---proves too complicated for quick configuration routines of a simple thermostat. The predefined gesture semantics do not match the custom navigation behavior required by the application (e.g., context-dependent button actions, quick wizard-style page flows). For this reason, native LVGL input callbacks are not used. Instead, a dedicated \textit{Router} component is introduced to receive input events from the InputTask and forward them to the active presenter, enabling full control over gesture interpretation.

Furthermore, certain system state changes must provoke specific page transitions or restrict user interactions---for instance, during an ongoing adaptation procedure or while the SystemTask awaits completion of the Configuration on Device (COD). This requires navigation to be partially state-driven rather than purely user-driven as in classical MVC or MVP. The Router addresses this by reading the current system state from the SystemModel to determine which page to display.

The resulting pattern is referred to as Routed MVP (R-MVP). In the presented architecture, its entire logic is encapsulated within the ViewPresenterTask.

\subsubsection{R-MVP Components}
\label{subsubsec:R-MVP Components}
The pattern comprises four component types:
\begin{itemize}
    \item \textbf{Router}: Manages screen navigation and page transitions based on the system state read from the SystemModel. It initializes and deinitializes presenters for each page, forwards input events from the InputTask to the currently active presenter, and can send events to the SystemTask to initiate state transitions.
    \item \textbf{Presenters}: Handle presentation logic and user interactions. They receive input events from the router, read and write shared models, and instruct views to update display elements. Presenters can be nested to implement multi-step wizard workflows.
    \item \textbf{Views}: Pure rendering components using LVGL, responsible solely for updating graphical elements on the display using data provided by the Presenters.
    \item \textbf{Models}: The shared, thread-safe data structures (SensorModel, ConfigModel, SystemModel) described in \autoref{subsec:Overall Architecture}, passed to the ViewPresenterTask as parameters.
\end{itemize}

For simplicity and to reduce abstraction overhead in the embedded C environment, no explicit interfaces are used; presenters call views directly. Since page content differs significantly across screens, this does not introduce code duplication.

\subsubsection{R-MVP Data Flow}
\label{subsubsec:R-MVP Data Flow}
The data flow follows a path through four stages:
\begin{enumerate}
    \item The InputTask generates input events and sends them to the Router via an event queue.
    \item The Router receives input events and forwards them to the currently active Presenter.
    \item The active Presenter processes the event, reading from or writing to the shared Models (with mutex protection).
    \item The Presenter instructs the corresponding View to render the updated data on the display.
\end{enumerate}

This can be illustrated in \autoref{fig:r-mvp}, which shows the data and control flow between the components of the R-MVP pattern. Comparing this flow with the classic MVP flow in \autoref{fig:mvp}, it can be seen that only the path of user input has changed, which now leads from the Router to the Presenter instead of from the View.

\begin{figure}[htbp]
    \centerline{\includegraphics[height=0.25\textheight]{../diagrams/r-mvp.png}}
    \caption{Data flow in the R-MVP programming model.}
    \label{fig:r-mvp}
\end{figure}

\subsubsection{Differences from Classical MVP}
\label{subsubsec:Differences from Classical MVP}
Three key deviations distinguish R-MVP from the classical pattern:
\begin{itemize}
    \item \textbf{Centralized Router}: Instead of presenters managing navigation between views, a dedicated Router component centralizes page navigation logic and input event forwarding. Routing decisions are partially state-driven, based on the current system state read from the SystemModel, rather than being purely user-driven as in classical MVP.
    \item \textbf{Separated Input Handling}: Input events do not originate from the views (as they would via LVGL callbacks in a classical approach) but are received by the Router from the InputTask and forwarded to the active presenter. This bypasses LVGL's built-in input device model and enables custom gesture interpretation tailored to the rotary encoder and button hardware.
    \item \textbf{Hierarchical Structure}: Presenters are initialized and deinitialized by the Router based on the active page; nested presenters are initialized by their parent presenters; views are initialized by their corresponding presenters.
\end{itemize}

\section{Implementation}
In this section, main challenges encountered during implementation are discussed, along with the solutions adopted to address them. 

\subsection{Interaction of ViewPresenterTask with SystemTask}
\label{subsec:Interaction with SystemTask}

Implementation of a paritally state-driven UI requires tight synchronization between the ViewPresenterTask and the SystemTask in certain phases. Their interaction points can be clearly identified in the diagram of the `SystemTask` state machine, shown in \autoref{fig:mt-rt-sw-system-task-state-machine}.

The ViewPresenterTask interacts with the SystemTask through two mechanisms: event queues for discrete notifications (e.g., \texttt{EVT\_SYS\_INIT\_END}, \texttt{EVT\_COD\_END}) and direct reading/writing of the SystemModel for state-dependent routing and display updates.

\begin{figure*}[htbp]
    \includegraphics[width=\textwidth]{../diagrams/mt-rt-sw-system-task-state-machine.png}
    \caption{State machine of the SystemTask}
    \label{fig:mt-rt-sw-system-task-state-machine}
\end{figure*}

During initialization, the ViewPresenterTask waits for \texttt{EVT\_SYS\_INIT\_END} from the SystemTask before rendering. After that, the SystemTask waits for \texttt{EVT\_COD\_END} to signal the completion of Configuration on Device. Beyond initialization, the router reads the system state directly from the SystemModel to determine which pages to render, without requiring further events from the SystemTask.

\subsection{Boilerplate Code in Router}
\label{subsec:Boilerplate Code in Router}

Since a verbose programming language (C) is used, the Router contains a significant amount of boilerplate code for initializing and deinitializing presenters and views, as well as for forwarding input events. This could be substantially reduced by using a language with advanced abstraction features, such as Rust, which is well-suited for embedded systems and typically provides compile-time abstractions with minimal or no runtime overhead (e.g., generics, pattern matching, and zero-copy trait implementations). However, the decision to use C was made based on the target hardware's ecosystem and the desire for maximum compatibility with existing embedded development tools and libraries.

\section{Verification and Results}
Text\dots
\subsection{Test Environment}
Text\dots
\subsection{Results}
Text\dots


\section{Conclusion}
Text\dots

%
%--Example Content-------------------------------------------------------------%
%
% Paragraphs example:

% \paragraph{Paragraph 1} 
% Text\dots
% \paragraph{Paragraph 2} 
% Test citation: \cite{IEEEwebsite}.

% Table example:

% \begin{table}[htbp]
% \caption{Table Type Styles}
% \begin{center}
% \begin{tabular}{|c|c|c|c|}
% \hline
% \textbf{Table}&\multicolumn{3}{|c|}{\textbf{Table Column Head}} \\
% \cline{2-4} 
% \textbf{Head} & \textbf{\textit{Table column subhead}}& \textbf{\textit{Subhead}}& \textbf{\textit{Subhead}} \\
% \hline
% copy& More table copy$^{\mathrm{a}}$& &  \\
% \hline
% \multicolumn{4}{l}{$^{\mathrm{a}}$Sample of a Table footnote.}
% \end{tabular}
% \label{tab1}
% \end{center}
% \end{table}

% Figure example:

% \begin{figure}[htbp]
% \centerline{\includegraphics{figures/fig1.png}}
% \caption{Example of a figure caption.}
% \label{fig}
% \end{figure}

%
%--Appendices-------------------------------------------------------------------%
%
%\appendices

% Appendix A
%\section{Title of Appendix A}
%Text\dots

% Appendix B
%\section{}
%Text\dots

%--Acknowledgment---------------------------------------------------------------%
%\section*{Acknowledgment}
%Text\dots

%--Bibliography-----------------------------------------------------------------%
\bibliographystyle{IEEEtran}
\bibliography{./bibtex/bib/bibliography}

\end{document}
